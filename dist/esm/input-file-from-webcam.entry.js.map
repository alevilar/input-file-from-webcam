{"file":"input-file-from-webcam.entry.js","mappings":"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","names":[],"sources":["./src/utils/camera.ts","./src/components/input-file-from-webcam/input-file-from-webcam.css?tag=input-file-from-webcam&encapsulation=shadow","./src/components/input-file-from-webcam/input-file-from-webcam.tsx"],"sourcesContent":["\nexport class CameraService {\n\n    elVideo: HTMLVideoElement;\n    stream: MediaStream;\n    canvas: HTMLCanvasElement;\n    constructor() {\n    }\n\n    public fotoActual: any;\n\n    initCamera( elVideo: HTMLVideoElement, elCanvas: HTMLCanvasElement, facingMode: ConstrainDOMString = {exact: \"user\"}, drawImageCb: Function = null ) {\n        this.resetCamera();\n        this.elVideo = elVideo;\n        this.canvas = elCanvas\n        \n        this.elVideo.parentNode.insertBefore(this.canvas, this.elVideo.nextSibling);\n\n        if (navigator.mediaDevices.getUserMedia) {\n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { min: 200 },\n                    height: { min: 200 },\n                    facingMode: facingMode\n                }\n            })\n            .then((stream) => {\n                this.stream = stream;\n                this.elVideo.srcObject = this.stream;\n\n                this.renderToCanvas( drawImageCb );\n            })\n            .catch(function (err0r) {\n                console.log(\"Something went wrong!\", err0r);\n            });\n        }\n    }\n\n\n    renderToCanvas( drawImageCb: Function = null) {\n\n        let ctx = this.canvas.getContext('2d');\n\n        let imgWidth = this.elVideo.videoWidth;\n        let imgHeight = this.elVideo.videoHeight;\n\n    \tvar imgSize = Math.min(imgWidth, imgHeight);\n        // The following two lines yield a central based cropping.\n        // They can both be amended to be 0, if you wish it to be\n        // a left based cropped image.\n    \tvar left = (imgWidth - imgSize) / 2;\n    \tvar top = (imgHeight - imgSize) / 2;\n\n        if ( typeof drawImageCb == 'function' ) {\n            drawImageCb.call(ctx, this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height)\n        } else {\n            ctx.drawImage(this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n        }\n\n        requestAnimationFrame(() => this.renderToCanvas() );\n\n    }\n\n    resetCamera() {\n        if (this.stream) this.stream?.getVideoTracks()?.forEach(track => {\n            track?.stop()\n            this.stream?.removeTrack(track)\n        });\n        if (this.elVideo) this.elVideo.srcObject = null;\n    }\n\n    async takePic(): Promise<File> {\n        return new Promise((resolve, reject) => {\n            try {\n                this.canvas.toBlob( (blob) => {\n                    const filename = \"pic_\" + Math.abs( Math.round( Math.random() * 1000))\n                    var file = new File([blob], filename, {type: \"image/jpeg\"});\n                    resolve(file);\n                }, \"image/jpeg\", 0.8)\n            } catch (error) {\n                reject(error);\n            }\n\n          });\n\n    }\n\n}\n\nexport const camera = new CameraService();\n",":host {\n  display: inline-block;\n  width: 100px;\n  filter: drop-shadow(2px 4px 6px black);\n  border: #5a5252 1px solid;\n  border-style: groove;\n}\n\n\nvideo {\n  display: none;\n}\n\ncanvas {\n  width: 100%;\n  height: 100%;\n}","import { Component, Host, h, Method, Listen, Prop, Event, EventEmitter } from '@stencil/core';\nimport { camera } from '../../utils/camera';\n\nexport type cameratipes = \"user\"|\"environment\"\n\n@Component({\n  tag: 'input-file-from-webcam',\n  styleUrl: 'input-file-from-webcam.css',\n  shadow: true,\n})\nexport class InputFileFromWebcam {\n\n  private elVideo: HTMLVideoElement\n  private elCanvas: HTMLCanvasElement\n\n\n  @Prop() width?: number = 460\n  @Prop() height?: number = 460\n\n  /**\n   * FacingModel optiones following https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode#value\n   */\n  @Prop({ mutable: true, reflect: true }) facingMode?: cameratipes = \"user\"\n\n  /**\n   * you can pass a function and override the canvas.drawImage function so you\n   * can change the image adding filters or any kind of magin in your image\n   * \n   * you just need to crear a function with all canvas.-drawImage arguments\n   * \n   * here you have the list of vars you get: videoElement, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height\n   */\n  @Prop() drawImageCb?: Function = null\n\n  @Method()\n  async takePic(): Promise<File> {\n    // show a prompt\n    const pic = await camera.takePic()\n    this.pictureTaken.emit(pic);\n    return pic\n  }\n\n  @Method()\n  async toggleCamera(): Promise<void>{\n    this.__toogleFacingMode()\n  }\n\n\n  @Event({\n    eventName: 'pictureTaken',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) pictureTaken: EventEmitter<File>;\n\n  @Event({\n    eventName: 'facingModeChanged',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) facingModeChanged: EventEmitter<cameratipes>;\n\n\n\n  @Listen('click')\n  onClickHandler() {\n    this.__toogleFacingMode()\n  }\n\n \n\n  /**\n   * Toogle webcam, for example in mobile show front or back camera\n   * you can block this behaviour by setting the facingMode Property\n   */\n  private __toogleFacingMode() {\n    // only change if no facinMode property was set\n    this.facingMode = (this.facingMode != \"user\") ? \"user\" : \"environment\"\n    this.facingModeChanged.emit( this.facingMode   )\n  }\n\n  __createfacingModeConstrainDOMString(): ConstrainDOMString {\n    return {ideal: this.facingMode}\n  }\n\n\n  componentWillMount() {\n   \n\n  }\n  \n  async componentDidRender() {\n    camera.initCamera( this.elVideo, this.elCanvas, this.__createfacingModeConstrainDOMString(), this.drawImageCb );\n  }\n\n  async disconnectedCallback() {\n    camera.resetCamera()\n  }\n\n  render() {\n    return (\n      <Host>\n\n        <slot name='before'></slot>\n        <video autoplay=\"true\" ref={(el) => this.elVideo = el }></video>\n        <canvas ref={(el) => this.elCanvas = el } width={this.width} height={this.height}></canvas>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"],"version":3}